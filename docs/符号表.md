# Semantics-Reference

## 实验介绍

在完成了词法分析以及语法分析后，我们将会从上下文无关分析阶段进入到上下文相关分析阶段。顾名思义，在之前的阶段中，我们并没有处理与输入代码的上下文相关的内容，例如在函数体中给一个没有声明的变量赋值，将一个INT类型的变量赋值为数组，调用函数时传入的参数与函数定义的参数不相同等等。

本次实验的关键就在于如何处理代码中上下文相关的内容，并且检查各种行为都是安全合法，即语义正确的。如果检测到了代码中的语义错误，就需要将其打印出来，没有错误就不用输出任何内容。

## 实验步骤

### 设计类型

> 类型: 一组值,以及在这组值上的一系列操作。当我们在类型上面尝试去执行其不支持的操作时,类型错误就会产生。

为了满足类型检查的需要,我们就需要将`SysY`语言中定义的类型用特定的数据结构实现出来。

给定一个符号`a` ,在`SysY`语言中,它可以是 INT这样的基本类型,也可以对应由基本类型构造出来的ARRAY ,当我们
在 a 的后面添加括号时,它又可以被理解成一个 FUNCTION 。

你可以创建多个类来表示上述的类型,并继承一个抽象父类 TYPE。对于`SysY`语言，我们建议你建立如下的基本类型：数组、函数、INT整数、指针类型。

另外,根据每个类型的值以及操作可以得到以下约束：

+ 基本类型的类无需存储其他内容
+ ARRAY 类需要存储其element类型以及element数量
+ FUNCTION 类需要存储其返回类型以及每个参数的类型
+ POINTER 类需要记录它指向的变量的类型

当然,你也可以根据你的理解,合理的实现不同的类型类。

对于 FUNCTION 的参数存储，你可以选择链表或者数组列表这样的的数据结构实现,使用数组列表结构的代码实现如下：

```java
public class FunctionType extends Type {
    private Type retTy;
    private ArrayList<Type> paramsType;
    ...
}

```

以上代码仅供参考,实际编写代码时请将不同类放到不同java文件中,并灵活根据需要修改其内容。

### 设计符号表

> 设计好类型后,下一步你应该思考如何存储一个符号的类型信息,以及给定一个符号名,如何得到它的类型信息,这就需要符号表来帮忙。

符号表上的操作包括填表和查表两种,在定义一个新的符号的时候，你需要往符号表里添加这个符号名以及它对应的信息；在使用一个符号的时候，你需要判断符号表中是否存在这个符号的信息并且从符号表中得到这个符号的所有信息。

在本学期的实验中，你需要将程序中出现的所有符号组织成一张嵌套层次的符号表。

至于符号表该用哪种数据结构,你可以按照你的需求自由实现,包括但不限于

+ 线性链表，添加效率极高,查找和删除效率较低
+ 平衡二叉树，较高的查找，添加，删除效率，但实现难度较高
+ 散列表，查找，添加，删除效率都极高，但是需要解决哈希冲突的问题，是符号表的实现中最常被采用的数据结构
+ …

对于散列表，下面给出了一个不错的hash函数选择，HASH_TABLE_SIZE 描述了散列表的大小，

```java
private int getHashIndex(String name) {
	int val = 0, i;
	for (char c : name.toCharArray()) {
		val = (val << 2) + (int) c;
		// HASH_TABLE_SIZE描述了符号表的大小
		if ((i = (val & ~HASH_TABLE_SIZE)) != 0) {
			val = (val ^ (i >> 12)) & HASH_TABLE_SIZE;
		}
	}
	return val;
}
```

当然,你也可以选择Java已经提供的集合类来表示符号表,但这种方式并不推荐。

至于在符号表里应该填什么,这取决于你本身,只要觉得方便,可以向符号表中填入任何内容,下面给出一种示范。

### 遍历语法树以及发现错误语义

在定义好类型以及符号表之后，下一步需要做的就是通过语法树上处理上下文相关的内容并检测出可能出现的违背了`SysY`语言特性的语义错误。

以下叙述中 walker 的 walk() 以及 visitor 的 visit() 统称为访问。

通过前面的实验,相信你已经对Antlr的listener模式或visitor模式有了一个大概的了解,它们分别使用不同的机制来访问树节点。

在上下文分析中，如何获取上下文的内容至关重要,我们无非就是希望在访问父节点的方法中得到的值能够传递到访问子节点的方法中，以及在访问完一个子节点后，能够以某种方式将得到的值再返回给访问父节点的方法使用。这样说可能会有点抽象，请看以下例子：

规则`varDecl : bType varDef (COMMA varDef)* SEMICOLON;`常用来声明一个全局变量

对于`int main(int a){
    	return a;
	 }`

我们可以得到这样的一棵语法树（添加了颜色，省略了部分无关的语法单元）

```java
Program
  CompUnit
    FuncDef
      FuncType
        int INT[orange]
      main IDENT[red]
      FuncFParams
        FuncFParam
          BType
            int INT[orange]
          a IDENT[red]
        BlockItem
          Stmt
            return RETURN[orange]
            Exp
              LVal
                a IDENT[red]
```

在访问树节点`FuncDef`的时候，按照顺序我们之后会依次访问`FuncType`、`IDENT`、`FuncFParams`